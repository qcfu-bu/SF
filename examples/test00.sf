import math;

// primitive attributes
// @main         -- main entry point
// @attribute    -- attribute of attributes
// @lazy         -- lazy initialization
// @extern       -- external function or class
// @inline       -- inline function
// @noinline     -- do not inline function

module Core {

// this is a line comment
/* this is a block comment */

interface Functor {
    type Self<A>;
    func map<A,B>(x: Self<A>, f: A -> B) -> Self<B>;
}

interface Monad {
    type Self<A>;
    func pure<A>(x: A) -> Self<A>;
    func bind<A,B>(self: Self<A>, f: A -> Self<B>) -> Self<B>;
}

extension<M: Monad> M: Functor {
    type Self<A> = M.Self<A>; 
    func map<A,B>(x: Self<A>, f: A -> B) -> Self<B> {
        x.bind(a => pure(f(a)))     
    }
}

enum Option<T> { 
    case None
    case Some(T)
}

extension<A> Option<A>: Monad where A : Functor {
    type Self<A> = Option<A>; 

    func pure<A>(x: A) {
        Some(x)
    }

    func bind<A,B>(self: Option<A>, f: A -> Option<B>) -> Option<B> {
        switch self {
        case Some(x): 
            print("some case");
            return f(x)
        default: 
            print("default case");
            return None
        } 
    }
}

interface Index<T> {
    type Self<T>;
    func index(self: Self<T>, x: Int) -> T;
}

interface Update<T> {
    type Self<T>;
    func update(self: Self<T>, x: Int, value: T);
}

@extern("fy_array_t") 
class Array<T>;

extension<T> Array<T>: Index<T> {
    type Self<T> = Array<T>;

    @extern("fy_array_index")
    func index(self: Array<A>, x: Int) -> A;
}

extension<T> Array<T>: Update<T> {
    type Self<T> = Array<T>;

    @extern("fy_array_update")
    func update(self: Array<T>, x: Int, value: T);
}

class Vec<T> {
    private let mut data: Array<T> = data;
    private let mut capacity: Int = capacity;
    private let mut len: Int = len;

    init(self) {
        self.data = Array(0); 
        self.capacity = 0;
        self.len = 0;
    }

    init(self, capacity: Int) {
        self.data = Array(capacity);
        self.capacity = capacity;
        self.len = 0;
    }

    func len(self: Vec<T>) -> Int {
        self.len
    }

    func push(self: Vec<T>, value: T) {
        if self.len >= self.capacity {
            let new_capacity = if self.capacity == 0 {
                4 
            } else if ok {
                self.capacity * 2 
            };
            let new_data = Array(new_capacity); // allocate new array with new_capacity
            for i in range(0, self.len) {
                new_data[i] = self.data[i];
            }
            self.data = new_data;
            self.capacity = new_capacity;
        }
        self.data[self.len] = value;
        self.len += 1;
    }
}

interface Into<A> {
    type Self;
    func into(self: Self) -> A;
}

interface From<A> {
    type Self;
    func from(x: A) -> Self;
}

extension<A,B: From<A>> A: Into<B> {
    open Option.*;

    type Self = A;
    func into(self: Self) -> B {
        B.from(self)
    }
}

}